#pragma kernel CreatePathLodList
#pragma kernel CreateBaseNode
#pragma kernel CreateNodeLodMap
#pragma kernel FrustumCull
#pragma kernel NodeConvertToPatch
#pragma kernel HizCull



#pragma multi_compile_local __ _REVERSE_Z
#pragma multi_compile_local __ _OPENGL_ES_3

struct NodePatchData{
    float3 boundsMax;
    float3 boundsMin;
    uint2 nodeXY;
    uint2 patchXY;
    uint LOD;
    int4 LodTrans;
};

struct BaseData{
    float3 cameraWorldPos;
    float fov;
    float patchSize;
    int nodeDevidePatchNum;
    float worldSize;
    float worldHeightScale;
    float lodJudgeFector;
    float2 hizMapSize;
    int gridNum;
    int maxLOD;
};

struct Bound
{
    float3 minPos;
    float3 maxPos;
};

AppendStructuredBuffer<NodePatchData> _AppendTempList;
AppendStructuredBuffer<NodePatchData> _FinalPatchList;
ConsumeStructuredBuffer<NodePatchData> _ConsumeList;

Texture2D<float2>_MinMaxHeightMap;
uniform float4 _GlobalValues[10];
uniform int _NodeIndexs[10];
uniform uint _CurrentLOD;
RWTexture2D<float> _SectorLODMap;
RWBuffer<uint>_NodeBrunchList;
int NoHizCull;

//HizCull
uniform float4x4 _VPMatrix;
Texture2D<float> _HizMap;
RWBuffer<uint> _InstanceArgs;
RWTexture2D<float4> _ResultPatchMap;

#include "./GPUTerrainFunc.hlsl"



[numthreads(1,1,1)]
void CreateBaseNode(uint3 id : SV_DispatchThreadID)
{
    BaseData baseData = GenerateBaseData(_GlobalValues);
    NodePatchData nodeData = CreateEmptyNodePatchData();
    nodeData.nodeXY = id.xy;
    nodeData.LOD = baseData.maxLOD;
    _AppendTempList.Append(nodeData);
}



[numthreads(1,1,1)]
void CreatePathLodList (uint3 id : SV_DispatchThreadID)
{
    BaseData baseData = GenerateBaseData(_GlobalValues);
    //Get BaseNodeData(5x5)
    NodePatchData nodeData = _ConsumeList.Consume();

    //Set Data
    uint2 nodeXY = nodeData.nodeXY;
    nodeData.LOD = _CurrentLOD;
    CalNodeBounds(baseData,nodeData);
    int nodeIndex=GetNodeIndex(baseData, nodeData.LOD,nodeXY);
    uint needQuad = IsNeedQuad(baseData, nodeData);
    
    if(needQuad==1)
    {
        NodePatchData nodeData0=CreateEmptyNodePatchData();
        NodePatchData nodeData1=CreateEmptyNodePatchData();
        NodePatchData nodeData2=CreateEmptyNodePatchData();
        NodePatchData nodeData3=CreateEmptyNodePatchData();

        nodeData0.nodeXY = nodeXY * 2;
        nodeData1.nodeXY = nodeXY * 2 + uint2(0, 1);
        nodeData2.nodeXY = nodeXY * 2 + uint2(1, 0);
        nodeData3.nodeXY = nodeXY * 2 + uint2(1, 1);

        _AppendTempList.Append(nodeData0);
        _AppendTempList.Append(nodeData1);
        _AppendTempList.Append(nodeData2);
        _AppendTempList.Append(nodeData3);

         _NodeBrunchList[nodeIndex] = 1;
         
    }
    else
    {
        _FinalPatchList.Append(nodeData);
        _NodeBrunchList[nodeIndex]=2;
    }

}

[numthreads(8, 8, 1)]
void CreateNodeLodMap(uint3 id :SV_DispatchThreadID)
{
    BaseData baseData = GenerateBaseData(_GlobalValues);
    uint2 sectorID = id.xy;
    for (int i = baseData.maxLOD; i > -0; i--)
    {
        int2 nodeXY = sectorID >> i;
        uint nodeIndex = GetNodeIndex(baseData, i, nodeXY);
        uint isbrunch = _NodeBrunchList[nodeIndex];
        if (isbrunch == 2)
        {
            _SectorLODMap[sectorID] = i * 1.0 / baseData.maxLOD;
            return;
        }
    }
}

[numthreads(1,1,1)]
void FrustumCull(uint3 groupId : SV_GroupID)
{
    BaseData baseData = GenerateBaseData(_GlobalValues);
    NodePatchData nodeData = _ConsumeList.Consume();

    float2 center = GetNodeCenterPos(baseData, nodeData);
    float3 center_y0 = float3(center.x, 0, center.y);
    float4 frustumPlane[6];
    GetFrustumPlane(_GlobalValues, frustumPlane);

    bool frusAvalible = FrustumCullBound(center_y0 + nodeData.boundsMin, center_y0 + nodeData.boundsMax, frustumPlane);
    if (frusAvalible)
    {
        _AppendTempList.Append(nodeData);
    }
}

[numthreads(1,1,1)]
void NodeConvertToPatch(uint3 id:SV_GroupThreadID) 
{
    NodePatchData nodeData = _ConsumeList.Consume();
    BaseData baseData = GenerateBaseData(_GlobalValues);
    int patchNum = baseData.nodeDevidePatchNum;

    for (int i = 0; i < patchNum; i++) 
    {
        for (int j = 0; j < patchNum; j++) 
        {
            NodePatchData patchData = CreateEmptyNodePatchData();
            patchData.nodeXY = nodeData.nodeXY;
            patchData.LOD = nodeData.LOD;
            patchData.patchXY = uint2(i, j);
            _AppendTempList.Append(patchData);
        }
    }
}


[numthreads(1,1,1)]
void HizCull(uint3 id:SV_DispatchThreadID) 
{
    BaseData baseData = GenerateBaseData(_GlobalValues);

    NodePatchData patchData = _ConsumeList.Consume();

    float patchSize = GetPatchSizeInLod(baseData, patchData.LOD);
    float2 nodePos = GetNodeCenterPos(baseData, patchData);
    float2 patchPosInNode = GetPatchPosInNode(baseData, patchData.patchXY, patchData.LOD);

    float2 patchPos = nodePos + patchPosInNode;

    uint2 patchUV = patchData.nodeXY * baseData.nodeDevidePatchNum + patchData.patchXY;

    float2 heightRange = (_MinMaxHeightMap.mips[patchData.LOD][patchUV].xy - 0.5) * 2 * baseData.worldHeightScale;

    GetLodTrans(patchData, baseData);

    float3 boundMin = float3(patchPos.x - patchSize * 0.5, heightRange.x, patchPos.y - patchSize * 0.5);
    float3 boundMax = float3(patchPos.x + patchSize * 0.5, heightRange.y, patchPos.y + patchSize * 0.5);

    bool isHizAvalible = HizCullBound(baseData, boundMin, boundMax);
    if (isHizAvalible == false)
    {
        return;
    }
    uint currentIndex;
    InterlockedAdd(_InstanceArgs[1], 1, currentIndex);
    uint2 pixXY;
    pixXY.y = currentIndex * 2 / 512;
    pixXY.x = currentIndex * 2 - pixXY.y * 512;

    float4 pix0, pix1;
    pix0.x = patchData.nodeXY.x;
    pix0.y = patchData.nodeXY.y;
    pix0.z = patchData.patchXY.x * 100 + patchData.patchXY.y;
    pix0.w = patchData.LOD;
    pix1 = patchData.LodTrans;
    _ResultPatchMap[pixXY] = pix0;
    _ResultPatchMap[pixXY + uint2(1, 0)] = pix1;
}
