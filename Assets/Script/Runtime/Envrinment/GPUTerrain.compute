#pragma kernel CreatePathLodList
#pragma kernel CreateBaseNode
#pragma kernel CreateNodeLodMap
#pragma kernel FrustumCull
#pragma kernel NodeConvertToPatch
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct NodePatchData{
    float3 boundsMax;
    float3 boundsMin;
    uint2 nodeXY;
    uint2 patchXY;
    uint LOD;
};

struct BaseData{
    float3 cameraWorldPos;
    float fov;
    float patchSize;
    int nodeDevidePatchNum;
    float worldSize;
    float worldHeightScale;
    float lodJudgeFector;
    int maxLOD;
};

AppendStructuredBuffer<NodePatchData> _AppendTempList;
AppendStructuredBuffer<NodePatchData> _FinalPatchList;
ConsumeStructuredBuffer<NodePatchData> _ConsumeList;

Texture2D<float2>_MinMaxHeightMap;
uniform float4 _GlobalValues[10];
uniform int _NodeIndexs[10];
uniform uint CURRENT_LOD;

RWBuffer<uint>NodeBrunchList;

inline BaseData GenerateBaseData(float4 valueList[10]){
    BaseData baseData;
    baseData.cameraWorldPos = float3(valueList[0].x, valueList[0].y, valueList[0].z);
    baseData.fov = valueList[0].w;
    baseData.patchSize=valueList[1].z;
    baseData.nodeDevidePatchNum =  valueList[2].x;
    baseData.worldSize=valueList[1].y;
    baseData.worldHeightScale = valueList[2].z;
    baseData.lodJudgeFector = valueList[2].y;
    baseData.maxLOD=valueList[1].x;
    return baseData;
}


NodePatchData CreateEmptyNodePatchData(){
    NodePatchData nodeData;
    nodeData.nodeXY = 0;
    nodeData.patchXY = 0;
    nodeData.LOD = 0;
    nodeData.boundsMax = 0;
    nodeData.boundsMin = 0;
    return nodeData;
}

[numthreads(1,1,1)]
void CreateBaseNode(uint3 id : SV_DispatchThreadID)
{
    BaseData baseData = GenerateBaseData(_GlobalValues);
    NodePatchData nodeData = CreateEmptyNodePatchData();
    nodeData.nodeXY = id.xy;
    nodeData.LOD = baseData.maxLOD;
    _AppendTempList.Append(nodeData);
}



inline float GetNodeSizeByLod(BaseData baseData, int LOD){
    return baseData.patchSize*baseData.nodeDevidePatchNum*(1<<LOD);
}

inline int GetNodeNumInLod(BaseData baseData, int LOD)
{
   return  floor(baseData.worldSize/GetNodeSizeByLod(baseData,LOD)+0.1f);
}

inline float2 GetNodeCenterPos(BaseData baseData,NodePatchData nodeData)
{
    float nodeSize = GetNodeSizeByLod(baseData,nodeData.LOD);
    uint nodeCount = GetNodeNumInLod(baseData, nodeData.LOD);
    float2 nodePos = nodeSize * (nodeData.nodeXY + 0.5 - nodeCount * 0.5);
    return nodePos;
}



void CalNodeBounds(BaseData baseData,inout NodePatchData nodeData){
    float2 height = _MinMaxHeightMap.mips[nodeData.LOD+3][nodeData.nodeXY].xy;
    float2 minMaxHeight = (height-0.5)*2*baseData.worldHeightScale;
    float nodeSize = GetNodeSizeByLod(baseData,nodeData.LOD);
    nodeData.boundsMax = float3(nodeSize*0.5,minMaxHeight.y,nodeSize*0.5);
    nodeData.boundsMin = float3(nodeSize*-0.5,minMaxHeight.x,nodeSize*-0.5);
}

int GetNodeIndex(BaseData baseData,uint LOD,float2 nodeXY){
    return _NodeIndexs[LOD]+nodeXY.y+nodeXY.x* GetNodeNumInLod(baseData,LOD);
}

uint IsNeedQuad(BaseData baseData,NodePatchData nodeData)
{
    if(nodeData.LOD==0)
        return 0;
    float3 cameraPos = baseData.cameraWorldPos;
    float fov = baseData.fov;
    float nodeSize = GetNodeSizeByLod(baseData, nodeData.LOD);
    float2 nodePos = GetNodeCenterPos(baseData,nodeData);

    float dis = distance(cameraPos, float3(nodePos.x, nodeData.boundsMax.y, nodePos.y));
    float result = baseData.lodJudgeFector * nodeSize / (dis * fov);
    return step(1, result);
}





[numthreads(1,1,1)]
void CreatePathLodList (uint3 id : SV_DispatchThreadID)
{
    BaseData baseData = GenerateBaseData(_GlobalValues);
    //Get BaseNodeData(5x5)
    NodePatchData nodeData = _ConsumeList.Consume();

    //Set Data
    uint2 nodeXY = nodeData.nodeXY;
    nodeData.LOD = CURRENT_LOD;
    CalNodeBounds(baseData,nodeData);
    int nodeIndex=GetNodeIndex(baseData, nodeData.LOD,nodeXY);
    uint needQuad = IsNeedQuad(baseData, nodeData);
    
    if(needQuad==1)
    {
        NodePatchData nodeData0=CreateEmptyNodePatchData();
        NodePatchData nodeData1=CreateEmptyNodePatchData();
        NodePatchData nodeData2=CreateEmptyNodePatchData();
        NodePatchData nodeData3=CreateEmptyNodePatchData();

        nodeData0.nodeXY = nodeXY * 2;
        nodeData1.nodeXY = nodeXY * 2 + uint2(0, 1);
        nodeData2.nodeXY = nodeXY * 2 + uint2(1, 0);
        nodeData3.nodeXY = nodeXY * 2 + uint2(1, 1);

        _AppendTempList.Append(nodeData0);
        _AppendTempList.Append(nodeData1);
        _AppendTempList.Append(nodeData2);
        _AppendTempList.Append(nodeData3);

         NodeBrunchList[nodeIndex] = 1;
         
    }
    else
    {
        _FinalPatchList.Append(nodeData);
        NodeBrunchList[nodeIndex]=2;
    }

}

RWTexture2D<float> _SectorLODMap;
[numthreads(8,8,1)]
void CreateNodeLodMap(uint3 id :SV_DispatchThreadID) 
{
    BaseData baseData = GenerateBaseData(_GlobalValues);
    uint2 sectorID = id.xy;
    for (int i = baseData.maxLOD; i > -0; i--)
    {
        int2 nodeXY = sectorID >> i;
        uint nodeIndex = GetNodeIndex(baseData, i, nodeXY);
        uint isbrunch = NodeBrunchList[nodeIndex];
        if (isbrunch == 2) 
        {
            _SectorLODMap[sectorID] = i * 1.0 / baseData.maxLOD;
            return;
        }
    }
}

inline void GetFrustumPlane(float4 valueList[10], inout float4 frustumPlane[6])
{
    frustumPlane[0] = valueList[4];
    frustumPlane[1] = valueList[5];
    frustumPlane[2] = valueList[6];
    frustumPlane[3] = valueList[7];
    frustumPlane[4] = valueList[8];
    frustumPlane[5] = valueList[9];
}

bool IsOutSidePlane(float4 plane, float3 position)
{
    return dot(plane.xyz, position) + plane.w < 0;
}


//true: avalible
//flase: culled
bool FrustumCullBound(float3 minPos, float3 maxPos, float4 planes[6])
{
    [unroll]
    for (int i = 0; i < 6; i++)
    {
        float3 p = minPos;
        float3 normal = planes[i].xyz;
        if (normal.x >= 0)
            p.x = maxPos.x;
        if (normal.y >= 0)
            p.y = maxPos.y;
        if (normal.z >= 0)
            p.z = maxPos.z;
        if (IsOutSidePlane(planes[i], p))
        {
            return false;
        }
    }
    return true;
}


[numthreads(1,1,1)]
void FrustumCull(uint3 groupId : SV_GroupID)
{
    BaseData baseData = GenerateBaseData(_GlobalValues);
    NodePatchData nodeData = _ConsumeList.Consume();

    float2 center = GetNodeCenterPos(baseData, nodeData);
    float3 center_y0 = float3(center.x, 0, center.y);
    float4 frustumPlane[6];
    GetFrustumPlane(_GlobalValues, frustumPlane);

    bool frusAvalible = FrustumCullBound(center_y0 + nodeData.boundsMin, center_y0 + nodeData.boundsMax, frustumPlane);
    if (frusAvalible)
    {
        _AppendTempList.Append(nodeData);
    }
}

[numthreads(1,1,1)]
void NodeConvertToPatch(uint3 id:SV_GroupThreadID) 
{
    NodePatchData nodeData = _ConsumeList.Consume();
    BaseData baseData = GenerateBaseData(_GlobalValues);
    int patchNum = baseData.nodeDevidePatchNum;

    for (int i = 0; i < patchNum; i++) 
    {
        for (int j = 0; j < patchNum; j++) 
        {
            NodePatchData patchData = CreateEmptyNodePatchData();
            patchData.nodeXY = nodeData.nodeXY;
            patchData.LOD = nodeData.LOD;
            patchData.patchXY = uint2(i, j);
            _AppendTempList.Append(patchData);
        }
    }
}

//get patchData around(left,down,right,up) lod 
//void GetLodTrans(inout NodePatchData patchData, BaseData baseData)
//{
//    patchData.LodTrans = 0;
//    int lod = patchData.LOD;
//    int2 sectorXY = patchData.nodeXY * (1 << lod);
//
//    if (patchData.patchXY.x == 0) {}
//}
//
//[numthreads(1,1,1)]
//void HizCull(uint3 :SV_DispatchThreadID) 
//{
//    BaseData baseData = GenerateBaseData();
//
//    NodePatchData patchData = _ConsumeList.Consume();
//
//    float patchSize = GetPatchSizeInLod(baseData, patchData.LOD);
//    float2 nodePos = GetNodeCenterPos(baseData, patchData);
//    float2 patchPosInNode = GetPatchPosInNode(baseData, patchData.patchXY, patchData.LOD);
//
//    float2 patchPos = nodePos + patchPosInNode;
//
//    uint2 patchUV = patchData.NodeXY * baseData.nodeDevidePatch + patchData.patchXY;
//
//    float2 heightRange = (MinMaxHeightMap.mips[patch.LOD][patchUV].xy - 0.5) * 2 * base.worldHeightScale;
//
//    GetLodTrans(patchData, baseData);
//}
